<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no, width=device-width" />
    <script src="../../../js/mui.min.js"></script>
    <link rel="stylesheet" href="./style.css">
    <link rel="stylesheet" href="../../../css/base.css">
    </link>
    <title>2048</title>
</head>

<body>
    <div class="wrapper">
        <div class="header">
            <div class="title">
                <h3 class="name">2048</h3>
                <div class="score-area">
                    <div class="score">
                        <span class="label">å·²å¾—åˆ†</span>
                        <span class="value">0</span>
                    </div>
                    <div class="best">
                        <span class="label">æœ€é«˜åˆ†</span>
                        <span class="value">0</span>
                    </div>
                </div>
            </div>
            <div class="btn">
                <div class="change-bgColor">ğŸ¨</div>
                <div class="new-game-btn">é‡ç½®</div>
            </div>
        </div>
        <div class="game-area">
            <div id="game-start">å¼€å§‹å§</div>
            <div id="board">
                <div class="board-box"></div>
                <div class="game-over">
                    <div class="label">æ¸¸æˆç»“æŸ!</div>
                </div>
            </div>
        </div>
    </div>
    <div class="footer">ã€Œ2048ã€ç®—æ³•ç”±<span id="link">Roy-Jin</span>ç¼–å†™å¹¶æä¾›æ”¯æŒ.</div>
</body>

<script>
    mui.init({
        swipeBack: false
    });

    mui.plusReady(function () {
        const muiBack = mui.back;
        let backConfirm;
        mui.back = () => {
            if (backConfirm) {
                backConfirm.close();
                return;
            }
            plus.device.vibrate(100);// éœ‡åŠ¨åé¦ˆ
            backConfirm = mui.confirm(
                "è¿™å°†ä¼šä¸¢å¤±ä½ çš„æ¸¸æˆè¿›åº¦ï¼Œ<br/>ç¡®å®šè¦ç¦»å¼€å—ï¼Ÿ<br/>" +
                "<p style='color: #999;font-size: 50%;margin-top: .5em;'>" +
                "(ä½†ä¼šè®°å½•ä½ çš„æœ€é«˜åˆ†)</p>", 'æç¤º', ['å–æ¶ˆ', 'ç¡®å®š'],
                (e) => {
                    if (e.index === 1) {
                        mui.later(() => muiBack(), 111);
                    } else {
                        backConfirm = null;
                    }
                }, "div")
        }
        document.getElementById('link').addEventListener('tap', () => {
            // å¼¹å‡ºç³»ç»Ÿé€‰æ‹©æŒ‰é’®æ¡†
            plus.nativeUI.actionSheet(
                {
                    cancel: "å–æ¶ˆæ“ä½œ",
                    buttons: [{ title: "Roy-Jin çš„ä¸ªäººç½‘ç«™" },{ title: "Roy-Jin çš„å¼€æºä¸»é¡µ" }]
                },
                (e) => {
                    if (e.index == 2) {
                        plus.runtime.openWeb('https://gitee.com/Roy-Jin');
                    } else if (e.index == 1) {
                        mui.toast('å³ä¸Šè§’åœ¨æµè§ˆå™¨æ‰“å¼€ä»¥è·å¾—æ›´æ£’çš„ä½“éªŒ~');
                        plus.runtime.openWeb('https://r-j.pages.dev/');
                    }
                }
            );
        })
    });
</script>

<script>
    const Map = {
        2: { color: '#333', bColor: '#ffffdd' },
        4: { color: '#111', bColor: '#ebbd96' },
        8: { color: '#f9f6f2', bColor: '#f2b179' },
        16: { color: '#f9f6f2', bColor: '#f59563' },
        32: { color: '#f9f6f2', bColor: '#f67c5f' },
        64: { color: '#f9f6f2', bColor: '#f65e3b' },
        128: { color: '#f9f6f2', bColor: '#edcf72' },
        256: { color: '#f9f6f2', bColor: '#edcc61' },
        512: { color: '#f9f6f2', bColor: '#edc850' },
        1024: { color: '#f9f6f2', bColor: '#edc53f' },
        2048: { color: '#f9f6f2', bColor: '#edc22e' },
        4096: { color: '#f9f6f2', bColor: '#DFC22E' },
        8192: { color: '#f9f6f2', bColor: '#CFCF22' },
        16384: { color: '#f9f6f2', bColor: '#CFCF22' },
        32768: { color: '#f9f6f2', bColor: '#3c3a32' },
    }


    /**
     * æ ¼å­ç±»
     */
    class Cell {
        /**
         * æ„é€ å‡½æ•°
         * @param {Number} row æ‰€åœ¨è¡Œå·
         * @param {Number} col æ‰€åœ¨åˆ—å·
         * @param {Number} value æ•°å€¼
         */
        constructor(row, col, value) {
            this.value = value
            this.row = row
            this.col = col

            // åˆ›å»ºdomå…ƒç´ ï¼Œå¹¶å¯¹å…¶é‡æ–°å®šä½
            this.dom = this.createDom(boardEl)
            this.reLocation('gen')
        }

        /**
         * åˆ›å»ºdomå…ƒç´ 
         */
        createDom(parentNode) {
            const dom = document.createElement('div')
            dom.innerText = this.value
            dom.className = 'cell real-cell'
            dom.style.color = Map[this.value].color || '#f9f6f2'
            dom.style.backgroundColor = Map[this.value].bColor || '#3c3a32'
            parentNode.append(dom)
            return dom
        }

        /**
         * é‡æ–°å®šä½
         */
        reLocation(type, r = this.row, c = this.col) {
            const padding = 0;

            const rect = this.dom.getBoundingClientRect()
            const fromLeft = rect.width * this.col + (this.col * padding) + 'px'
            const fromTop = rect.height * this.row + (this.row * padding) + 'px'
            const toLeft = rect.width * c + (c * padding) + 'px'
            const toTop = rect.height * r + (r * padding) + 'px'

            this.row = r
            this.col = c

            // this.dom.getAnimations().forEach(animate => animate.cancel())
            return this.dom.animate(getAnimations(type, { fromLeft, fromTop, toLeft, toTop }), { duration: 80, fill: 'forwards' })
        }

    }

    /**
     * æ ¹æ®ç±»å‹è·å–åŠ¨ç”»åˆ—è¡¨
     */
    function getAnimations(type, rect) {
        let list = []
        switch (type) {
            case 'gen':
                return [
                    { left: rect.fromLeft, top: rect.fromTop, transform: 'scale(0)' },
                    { left: rect.toLeft, top: rect.toTop, transform: 'scale(1)' }
                ]
            case 'move':
                return [
                    { left: rect.fromLeft, top: rect.fromTop },
                    { left: rect.toLeft, top: rect.toTop }
                ]
        }
        return list
    }

    const NEXT_DIRECTION = {
        ArrowUp: (r, c) => [r + 1, c],
        ArrowDown: (r, c) => [r - 1, c],
        ArrowLeft: (r, c) => [r, c + 1],
        ArrowRight: (r, c) => [r, c - 1]
    }

    const DIRECTION = {
        ArrowUp: (row, col, callback) => executeCallback(0, col, index => callback(0, index)),
        ArrowDown: (row, col, callback) => executeCallback(0, col, index => callback(row - 1, index)),
        ArrowLeft: (row, col, callback) => executeCallback(0, row, index => callback(index, 0)),
        ArrowRight: (row, col, callback) => executeCallback(0, row, index => callback(index, col - 1))
    }

    const eventList = {}

    /**
     * æ ¼å­æ£‹ç›˜
     */
    class CellBorder {

        constructor(row, col) {
            this.row = row
            this.col = col
            this.cellList = []
            // äº‹ä»¶åˆ—è¡¨
            this.eventList = {}
            // ç©ºç™½æ•°é‡
            this.blankCount = row * col
            // æ¸¸æˆç»“æŸæ ‡è¯†
            this.gameOver = false

            this.init()
        }

        /**
         * åˆå§‹åŒ–å‡½æ•°
         */
        init() {
            // åˆå§‹åŒ–å®¹å™¨
            this.initContainer()

            // ç”Ÿæˆéšæœºä¸¤ä¸ªcellï¼Œå¹¶æ·»åŠ åˆ°å®¹å™¨
            this.generatorCell(2)
        }

        /**
         * åˆå§‹åŒ–å®¹å™¨æ•°æ®
         */
        initContainer() {
            boardEl.innerHTML = ''
            for (let r = 0; r < this.row; r++) {
                const row = document.createElement('div')
                row.className = 'row-cell'
                this.cellList[r] = new Array(this.col)
                for (let c = 0; c < this.col; c++) {
                    const cell = document.createElement('div')
                    cell.className = 'cell'
                    row.appendChild(cell)
                }
                boardEl.appendChild(row)
            }
        }

        /**
         * ç”Ÿæˆéšæœºä¸¤ä¸ªcell
         */
        generatorCell(number = 1, options = [2, 4]) {
            if (number > this.blankCount) {
                number = this.blankCount
            }
            while (number-- > 0) {
                let r = getRandomInt(0, this.row)
                let c = getRandomInt(0, this.col)
                while (this.cellList[r][c]) {
                    r = getRandomInt(0, this.row)
                    c = getRandomInt(0, this.col)
                }
                // éšæœº2 || 4
                const index = getRandomInt(0, options.length)

                // åˆ›å»ºcell
                this.cellList[r][c] = new Cell(r, c, options[index])
                this.blankCount-- // ç©ºç™½ä½ç½®å‡å°‘
            }
        }

        /**
         * doCall
         */
        doCall(key) {
            const callback = DIRECTION[key]
            if (callback && !this.gameOver) {
                // åˆ¤æ–­æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (this.isGameOver()) {
                    this.gameOver = true
                    gameOverEl.classList.add('active')
                } else {
                    callback(this.row, this.col, (r, c) => this.call(r, c, key))

                    // é‡æ–°ç”Ÿæˆæ–°çš„cell
                    this.generatorCell()
                }
            }
        }

        /**
         * è®¡ç®—æ¯è¡Œï¼Œæ¯åˆ—
         */
        call(r, c, d) {
            if (!this.isRange(r, c)) return
            const curNode = this.cellList[r][c]
            // å¾—åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
            const nextNode = this.getNextNode(r, c, d)
            if (!nextNode) return
            const { row, col, value } = nextNode
            // å½“å‰ä½ç½®æ²¡æœ‰å…ƒç´ ï¼Œä½ç½®äº¤æ¢ï¼ˆç§»åŠ¨æ“ä½œï¼‰
            if (!curNode) {
                nextNode.reLocation('move', r, c)
                this.cellList[r][c] = nextNode
                this.cellList[row][col] = null
                return this.call(r, c, d)
            }
            // å½“å‰æœ‰å…ƒç´ å¹¶ä¸”å€¼ç›¸åŒï¼ˆåˆå¹¶æ“ä½œï¼‰
            else if (curNode.value === value) {
                const animate = nextNode.reLocation('move', r, c)
                this.cellList[row][col] = null
                setTimeout(e => {
                    boardEl.removeChild(nextNode.dom)
                    boardEl.removeChild(curNode.dom)
                    this.cellList[r][c] = new Cell(r, c, value * 2)
                }, 80)
                this.blankCount++ // ç©ºç™½ä½ç½®å¢åŠ 
                // å‘å¸ƒåŠ åˆ†äº‹ä»¶
                this.publishScore('score', value * 2)
            }
            // é€’å½’è¿›è¡Œä¸‹ä¸€ä¸ªcell
            const [nextR, nextC] = NEXT_DIRECTION[d](r, c)
            this.call(nextR, nextC, d)
        }

        /**
         * è·å–ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
         */
        getNextNode(r, c, d) {
            let [nextR, nextC] = NEXT_DIRECTION[d](r, c)
            while (this.isRange(nextR, nextC)) {
                if (this.cellList[nextR][nextC]) {
                    return this.cellList[nextR][nextC]
                }
                [nextR, nextC] = NEXT_DIRECTION[d](nextR, nextC)
            }
            return null
        }

        /**
         * æ£€æŸ¥æ˜¯å¦åœ¨èŒƒå›´å†…
         */
        isRange(row, col) {
            return row >= 0 && row < this.row && col >= 0 && col < this.col
        }

        /**
         * æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
         */
        isGameOver() {
            // å­˜åœ¨ç©ºç™½ä½ç½®ï¼Œæ¸¸æˆæ²¡æœ‰ç»“æŸ
            if (this.blankCount > 0) {
                return false
            }
            // å®šä¹‰æ–¹å‘
            const dir = [[1, 0], [0, 1]]

            // æ£€æŸ¥æ¯ä¸€ä¸ªcellå¯æ“ä½œï¼Œå­˜åœ¨å¯æ“ä½œ
            for (let r = 0; r < this.row; r++) {
                for (let c = 0; c < this.col; c++) {
                    for (let d = 0; d < dir.length; d++) {
                        let a = r + dir[d][0]
                        let b = c + dir[d][1]
                        // åœ¨èŒƒå›´å†…
                        if (this.isRange(a, b) && this.cellList[r][c].value === this.cellList[a][b].value) {
                            return false
                        }
                    }
                }
            }
            return true
        }

        /**
         * å‘å¸ƒäº‹ä»¶
         */
        publishScore(event, data) {
            eventList[event].call(this, data)
        }

        /**
         * è®¢é˜…äº‹ä»¶
         */
        subscribe(event, callback) {
            eventList[event] = callback
        }

    }

    /**
     * ç”Ÿæˆéšæœºæ•°
     * @param {Number} min æœ€å°å€¼
     * @param {Number} max æœ€å¤§å€¼
     * @returns ç»“æœ
     */
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min)) + min
    }

    /**
     * åœ¨èŒƒå›´å†…æ‰§è¡Œå›è°ƒ
     */
    function executeCallback(min, max, callback) {
        while (min < max) callback(min++)
    }

    let keydownFlag = false
    const scoreEl = document.querySelector('.score .value')
    const bestScoreEl = document.querySelector('.best .value')
    const newGameEl = document.querySelector('.new-game-btn')

    class Game {
        constructor([row, col], cacheKey) {
            this.row = row
            this.col = col
            this.totalScore = 0
            this.totalBestScore = localStorage.getItem(cacheKey) || 0
            bestScoreEl.innerText = this.totalBestScore

            this.cellBorder = new CellBorder(row, col)
            this.initEvent()
        }

        // åˆå§‹åŒ–äº‹ä»¶
        initEvent() {
            window.addEventListener('keydown', event => {
                if (!keydownFlag) {
                    keydownFlag = true
                    this.cellBorder.doCall(event.key)
                }
            })
            window.addEventListener('keyup', event => {
                keydownFlag = false
            })

            window.addEventListener("swiperight", event => {
                this.cellBorder.doCall('ArrowRight')
            })

            window.addEventListener("swipeleft", event => {
                this.cellBorder.doCall('ArrowLeft')
            })

            window.addEventListener("swipedown", event => {
                this.cellBorder.doCall('ArrowDown')
            })

            window.addEventListener("swipeup", event => {
                this.cellBorder.doCall('ArrowUp')
            })

            newGameEl.addEventListener('click', this.restart.bind(this))

            this.cellBorder.subscribe('score', this.addScore.bind(this))
        }

        /**
         * åŠ åˆ†
         */
        addScore(value) {
            this.totalScore += value
            if (this.totalScore > this.totalBestScore) {
                this.totalBestScore = this.totalScore
                localStorage.setItem(cacheKey, this.totalBestScore)
                bestScoreEl.innerText = this.totalBestScore
            }
            scoreEl.innerText = this.totalScore
            const effect = document.createElement('div')
            effect.innerText = '+' + value
            effect.className = 'effect'
            scoreEl.appendChild(effect)
        }

        /**
         * é‡æ–°å¼€å§‹
         */
        restart() {
            this.totalScore = 0
            this.cellBorder = new CellBorder(this.row, this.col)
            scoreEl.innerText = 0

            gameOverEl.classList.remove('active')
        }

    }

    const boardEl = document.querySelector(".board-box")
    const gameOverEl = document.querySelector(".game-over")
    const cacheKey = 'BEST_SCORE_2048';
    const cacheColor = 'CACHE_COLOR_2048';

    window.onload = function () {
        document.querySelector('.best .value').innerText =
            localStorage.getItem(cacheKey) || 0;

        // windowåŠ è½½å®Œæˆåï¼Œåˆ›å»ºæ¸¸æˆå¯¹è±¡
        document.querySelector("#game-start").addEventListener("click", function (e) {
            e.currentTarget.style.display = "none";
            document.querySelector("#board").style.display = "block";
            document.documentElement.style.setProperty('--board-bg', localStorage.getItem(cacheColor));
            const game = new Game([4, 4], cacheKey);
        })

        // åˆ‡æ¢é…è‰²
        document.querySelector(".change-bgColor").addEventListener("click", function (e) {
            mui.confirm("è¯·é€‰æ‹©ä½ è¦çš„æ“ä½œ", "è°ƒè‰²ç›˜", ["å–æ¶ˆ", "é‡ç½®é…è‰²", "åˆ‡æ¢é…è‰²"], function (e) {
                if (e.index === 1) {
                    localStorage.setItem(cacheColor, "#816311");
                    document.documentElement.style.setProperty('--board-bg', "#816311");
                } else if (e.index === 2) {
                    const input = document.createElement("input");
                    input.type = "color";
                    input.value = localStorage.getItem(cacheColor) || "#816311";
                    input.addEventListener("change", function (e) {
                        localStorage.setItem(cacheColor, e.target.value);
                        document.documentElement.style.setProperty('--board-bg', e.target.value);
                        input.remove();
                    });
                    input.click();
                }
            }, "div");
        });
    }
</script>

</html>